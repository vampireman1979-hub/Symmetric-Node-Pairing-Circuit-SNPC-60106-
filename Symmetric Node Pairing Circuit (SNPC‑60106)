from __future__ import annotations

from typing import Tuple

import numpy as np
from qiskit import Aer, QuantumCircuit
from qiskit.execute_function import execute  # for backward compatibility


INTEGRITY_CONSTANT: float = 60106.0
INTEGRITY_SCALE: float = 10000.0


def integrity_angle() -> float:
    """
    Return the Z-rotation angle (in radians) derived from the integrity constant.

    theta = (INTEGRITY_CONSTANT / INTEGRITY_SCALE) * pi
    """
    return float((INTEGRITY_CONSTANT / INTEGRITY_SCALE) * np.pi)


def build_integrity_circuit(
    num_qubits: int = 3,
    measure: bool = False,
) -> QuantumCircuit:
    """
    Build the Quantum Integrity Lattice circuit.

    The circuit performs:
      1. H on all qubits (uniform superposition).
      2. A linear entanglement chain via CX(i -> i+1).
      3. RZ(theta) on all qubits, where theta is derived from INTEGRITY_CONSTANT.
      4. H on all qubits (return to computational basis).
      5. Optional measurements on all qubits.

    Parameters
    ----------
    num_qubits:
        Number of qubits in the lattice (must be >= 1).
    measure:
        If True, add measurements on all qubits.

    Returns
    -------
    QuantumCircuit
        The constructed quantum circuit.
    """
    if num_qubits < 1:
        raise ValueError("num_qubits must be at least 1.")

    num_clbits = num_qubits if measure else 0
    circuit = QuantumCircuit(num_qubits, num_clbits)

    # 1. Initialization: H on all qubits
    for index in range(num_qubits):
        circuit.h(index)

    # 2. Entanglement: linear CX chain
    for control in range(num_qubits - 1):
        circuit.cx(control, control + 1)

    # 3. Phase: RZ(theta) on all qubits
    theta = integrity_angle()
    for index in range(num_qubits):
        circuit.rz(theta, index)

    # 4. Return to computational basis
    circuit.barrier()
    for index in range(num_qubits):
        circuit.h(index)

    # 5. Optional measurement
    if measure:
        for index in range(num_qubits):
            circuit.measure(index, index)

    return circuit


def simulate_statevector(
    num_qubits: int = 3,
) -> Tuple[QuantumCircuit, np.ndarray]:
    """
    Build and simulate the integrity circuit as a statevector.

    Parameters
    ----------
    num_qubits:
        Number of qubits in the lattice (must be >= 1).

    Returns
    -------
    (QuantumCircuit, np.ndarray)
        The constructed circuit and the resulting statevector.
    """
    circuit = build_integrity_circuit(num_qubits=num_qubits, measure=False)
    print("Quantum Integrity Lattice (TCC-Q1) initialized.\n")
    print(circuit.draw())

    backend = Aer.get_backend("statevector_simulator")
    job = execute(circuit, backend=backend)
    result = job.result()
    statevector = result.get_statevector()

    print(
        "\nStatevector simulation complete. "
        f"Integrity constant = {INTEGRITY_CONSTANT}."
    )
    print(statevector)

    return circuit, statevector
